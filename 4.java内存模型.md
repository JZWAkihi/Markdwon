## Java内存模型

​		`在并发程序中，涉及到操作系统的底层，因此我们很难去判断程序的执行是怎样的。同时涉及到多个线程对共享资源的访问。一致性和安全性将会受到严重挑战。所以，我们需要保证多个线程正确的协同工作。Java内存模型可以帮助我们解决这些问题。`

~~~markdown
# Java内存区域(结构)和Java内存模型
1. java内存区域和Java内存模型是两个不一样的东西。内存区域是指JVM运行时将数据分区域存储，强调与内存空间的划分。
2. Java内存模型时定义了线程和主内存之间的抽象关系，用来屏蔽各种硬件和操作系统的内存之间的访问差异。JMM定义了JVM在计算机内存中的工作方式。规范了Java虚拟机与计算机内存之间如何协同工作。Java内存模型跟CPU缓存模型类似，是基于CPU缓存模型来建立的。
~~~

~~~markdown
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量一定要是共享变量，比如实例字段，静态变量等。
~~~



### 1、CPU缓存

`为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化`

例如：CPU高速缓存。尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存(cache)以提高性能

![image-20210508082604913](https://gitee.com/Akihij/PicGo/raw/master/img/20210508082612.png)

#### 多级缓存

> L1 Cache(一级缓存) ：CPU第一层高速缓存，分为数据缓存和指令缓存。一般服务器CPU的L1缓存的容量通常在32-4096kb。
>
> L2 Cache(二级缓存) ：由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一高速存储器。
>
> L3 Cache(三级缓存) ：现在L3都是内置，它可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。一般是多核共享一个L3缓存。

==CPU在读取数据时，先在L1中寻找，再从L2寻找，再从L3寻找，然后是内存，再后是外存储器。==

#### 缓存同步协议

在多CPU读取同样的数据进行缓存，进行不同运算之后，最终写入主内存以哪个CPU为准？

`在这种高速缓存回写的场景下，有一个缓存一致性协议`，大多数的CPU厂商对它进行了实现。

MESI协议，它规定了每条缓存有个状态位，同时定义下面四个状态：

~~~markdown
修改态(Modified)      此缓存行已被修改过(脏行) ，内容以不同于主存，为此cache专有。

专有态(Exclusive)     此缓存行内容同于主存，但不出现于其他cache中

共享态(Shared)        此缓存行内容同于主存，可以出现在其他cache中

无效态(Invalid)       此缓存行内容无效。
~~~



多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU。

也就是意味着：`CPU处理器要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证最终一致`



#### 运行时指令重排序

==指令重排序也是CPU性能优化手段==

![image-20210508085016469](https://gitee.com/Akihij/PicGo/raw/master/img/20210508085016.png)

指令重排的场景：当CPU写缓存发现缓存区正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。



~~~markdown
# 举一个生活中的重排序例子
将一条鱼加工成鱼罐头需要50分钟，一次只能加工一条鱼。

可以将每个鱼罐头的加工流程分成5个步骤：
1. 去鳞清洗 10分钟
2. 蒸煮沥水 10分钟
3. 加注汤料 10分钟
4. 杀菌出锅 10分钟
5. 真空封罐 10分钟

我们可以通过这种方式来提高加工的效率。这种方法类似于计算机体系结构中的流水线技术。
~~~

![image-20210419150849274](https://gitee.com/Akihij/PicGo/raw/master/img/20210419150856.png)





但并非随便的重排序，需要遵守`as-if-serial`语义

> as-if-serial语义：
>
> 不管怎么重排序，单线程程序的执行结果不能被改变。也就是说，编译器和处理器不会对存在数据依赖关系的操作做重排序。

### 内存屏障

在多级缓存中存在的问题：

1. 缓存中的数据于主内存的数据不是实时同步的，各个缓存之间的数据也不是同步的。

2. 在多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误



因此，CPU厂商提供了==两个内存屏障指令(Memory Barrier)用于解决上述两个问题：

1. ==写内存屏障(Store Memory Barrier)==：在指令后插入Store Barrier，能让`写入工作内存中的最新数据更新写入主内存中，让其他线程可见。`强制将最新数据写入主内存中，这种显示调用，CPU就不会因为性能考虑而对指令重排。
2. ==读内存屏障(Load Memory Barrier)==：在指令前插入Load Barrier，可以让工作内存中的数据失效，强制从主内存中加载数据。



### 2、什么是主内存和工作内存

~~~markdown
# 什么是主内存和工作内存
java内存模型规定了所有的变量在主内存中。每个线程还有自己的工作内存。线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行。而不能直接去读写主内存中的变量。不同的线程之间无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。
~~~

~~~markdown
# 下图就是线程、主内存、工作内存三者的交互关系
~~~

![image-20210411120918064](https://gitee.com/Akihij/PicGo/raw/master/img/20210411120918.png)

### 3、内存之间的交互操作

~~~markdown
关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步会主内存。
Java内存模型定义了一下8中操作来完成，虚拟机实现时必须保证每一种操作都是原子操作。
~~~

~~~markdown
# 8种操作
1. lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态
2. unlick(解锁):作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
3. read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存，以便随后的load动作使用
4. load(载入):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
5. use(使用) :作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个这个操作
6. assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个需要变量赋值的字节码指令时将会执行这个这个操作
7. store(存储):作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用
8. write(写入):作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
~~~



~~~markdown
# 变量同步 (只需顺序执行操作，不需要连续执行操作)
如果要把一个变量从主内存复制到工作内存中，那就要顺序执行read和load操作。
如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。
~~~



~~~markdown
# 对于内存之间的交互，主要注意下面的几点：
1. 不允许read、load、store和write操作单独出现，也就是说，不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存执行回写操作但主内存不接受。

2. 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步到主内存。

3. 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步会主内存中。

4. 一个变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，也就是说对一个变量实施use和store操作之前，必须先执行过了assign和load操作。

5. 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁。

6. 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。

7. 如果变量实现没有被lock操作锁住，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁住的变量。

8. 对一个变量执行unlock操作之前，必须先把此变量同步会主内存中。
~~~



### 4、原子性、可见性和有序性

`Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性着3个特征来建立的。`

#### 原子性

`由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write。`

~~~markdown
原子型是指操作是不可分的，要么全部一起执行，要么不执行。在Java中，其表现在对于共享变量的某些操作，是不可分的，必须连续完成。
~~~

~~~markdown
# 例：对于i++操作，有下面几个操作
1. 读取变量i的值
2. 将i的值加1
3. 将值重新赋值给i

如果在进行着三个操作中的任何一个操作时，将i的值进行更改。都不会得到正确的值。因此对于i++操作必须是原子性的
~~~

#### 可见性

`可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。`



~~~markdown
# 为什么会有可见性
我们知道，在JMM中有以下规范
    定义的所有变量都存储在主内存中。
    每个线程都有自己独立的工作空间，里面保存了该线程使用到的共享变量的副本拷贝。
    线程对共享变量的操作都在自己的工作内存中进行，而非直接从主内存中读写。
    不同线程之间无法直接访问其他线程的共享变量
~~~

`线程需要修改一个共享变量i，需要先把i从主内存拷贝到该线程的工作内存中，在自己的工作内存中修改完毕之后，再从工作内存中回到主内存中。如果线程对变量的操作没有回写到主内存的话，没有改变主内存中共享变量的值，那么对其他线程是不可见的。如果其他线程没有读取主内存中新的值，而是使用旧的值，同样的也是不可见的`



#### 有序性

`有序性指的是程序严格按照代码先后顺序执行。`

我们知道，为了CPU的性能，我们允许 运行时指令重排序

~~~markdown
# 重排序对多线程的影响
在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因)。
但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。
~~~



##### 先行发生原则(happens-before)

~~~markdown
Java语言中有一个先行发生原则，他是判断数据是否存在竞争、线程是否安全的主要依据。依靠这个原则，我们可以通过几条规则解决并发环境下两个操作之间是否可能存在冲突的所有问题。
~~~

`happens-before是指两个操作存在确定的先后顺序，前面的操作产生的结果则可以被后面的操作使用。所谓确定的先后顺序，即是在任何情况下两个操作的先后顺序是确定不变的。`

`在多线程中，happens-berfore是确定变量是否线程安全的充要条件。也就是说，如果线程A先行发生于线程B，则线程A中的变量相对于线程B而言是线程安全的。反过来，没有遵循happens-before，则必须借助线程同步手段才能保证线程的安全性。`

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行在后面的操作
- 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作

- volatile变量规则：对一个变量的写操作先行于后面对这个变量的读操作。
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。
- 线程启动机制：Thread对象的start()方法先行发生于此线程每一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。
- 对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始

























